package\s*(\w*\.)*(\w*\.\*)+; :: package $1
package\s*(?:\w*\.)*([^;]+)(\.\*)?; :: package $1
import\s*(?:\w*\.)*([^;]+); :: import "$1"
namespace :: // namespace
(?:public|private)?(?P<indent>\s*)class\s*(?P<ClassName>\w+)\s*(\([^)]*\))?\s*{ :: type $ClassName struct {\n    $3
(?P<indentNew>\s*)public\s*{ClassName}\s*\(([^)]*)?\)\s*{ :: {indent}func New{ClassName} ($2)*{ClassName} {  // $1\n    ref := &{ClassName}{$2}
^(?P<indent>\s*)}$ :: {indent} }
((?:public|private|virtual|protected|override|event)\s)+\s*(\w*)?\s*{ClassName}\s*\(([^)]*)?\)\s*{ :: func (ref *{ClassName}) $2($3) { // $1
((?:public|private|virtual|protected|override|event)\s)+\s*(static)?\s*{ClassName}\s*(\w*)\s*\(([^)]*)?\)\s*{ :: func (ref *{ClassName}) $4($5) $3 { // $1 $2
((?:public|private|virtual|protected|override|event)\s)+\s*(\w*)?\s*(\w*)?\s*\(([^)]*)?\)\s*{ :: func (ref *{ClassName}) $2($3) $4 { // $1
((?:public|private|virtual|protected|final)\s)+\s*(\w+)\s+([^;]+); :: $3 $2 // $1
for\(int\s*(\w*)\s*=\s*(\d*);([^)]*)\) :: for $1 := $2; #3 {
(for\(\s*;\s*;\s*\))|while :: for true {
(try|catch) :: // $1
throw\s*new\s*(?:\w*Exception)?\(([^)]*)\) :: panic(errors.New($1))
(\s*)var\s*(\w*)\s*=\s*([\S]*)\s*\?{2}\s*([^;]*); :: $1$2 := $3 \n${1}if $2 == nil {\n$1    $2 = $3 \n${1}}
(\s*)return\s*\s*([\S]*)\s*\?{2}\s*([^;]*) :: ${1}if $2 != nil {\n$1    return $2 \n${1}}\n\n${1}return $3

#general rules
null :: nil
^\s*(@property|@abstractmethod|@staticmethod|@Override)$  :: // $1
@NotNull :: \s
void :: \s
;$  :: \s
\bstring\. :: strings.
\b_*(\w*) :: $1
this :: ref
\bString\b :: string
new\s+(\w+)\( :: New$1(
new\s{ClassName}\( :: New{ClassName}(
#func\s*New{ClassName}\s*\(((\w+)\s*(\w+)*)\)\s*{ :: func New{ClassName} ( forgroup($2,$1) ){



